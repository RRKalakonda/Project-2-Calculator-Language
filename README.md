# Project-2-Calculator-Language


##  Rishika Reva Kalakonda - rkalakon@stevens.edu

##  URL of this Git repo https://github.com/RRKalakonda/Project-2-Calculator-Language

I spent a considerable amount of time working on this project, particularly on implementing order precedence, parsing and evaluation of complex expressions. I ran into issues with some test cases, which I eventually realized was due to extra space characters being printed. This caused some frustration, but once corrected, the test cases began to pass. More test cases were passed after the professor corrected the wrong outputs in gradescope. Handling of op-equals operations for all binary operators also took decent amount of time.

Overall, it took me around 40 hours to complete the project. 

## Description of code & tests

This program is an implementation of a basic interpreter for a programming language. The code reads a program as a string input, tokenizes it into a list of tokens, parses the tokens to generate an abstract syntax tree (AST), and then evaluates the AST to execute the program.

The program consists of two main parts. The first part includes functions for tokenizing, parsing, and evaluating the AST, and the second part includes the main function that reads the input string, calls the tokenizing, parsing, and evaluating functions in sequence, and handles any exceptions or errors that occur during execution.

The tokenize function takes the input string and generates a list of tokens based on a set of rules that define how the language's keywords, operators, and values should be identified and represented. The function uses regular expressions to match patterns in the input string and generate tokens for each matched pattern.

The parse_program function takes the list of tokens generated by the tokenize function and converts it into an AST that represents the program's structure and logic. The function uses a recursive descent parsing algorithm that starts with the highest-level constructs in the language's grammar, such as statements and expressions, and then recursively breaks them down into lower-level constructs until it reaches the atomic level of individual tokens.

The evaluate function takes an AST node and a dictionary of variable values and evaluates the node's value based on its type and the values of its sub-nodes. The function recursively traverses the AST, evaluating each node in the proper order, until it reaches the end of the tree. The function supports a range of operators and expressions, including arithmetic operations, comparison operators, logical operators, assignment operators, and increment/decrement operators.

The comment_parser function takes the input string and removes any comments that are enclosed in either '#' or '/' and '/'. This function helps to simplify the input string and remove any irrelevant information that could cause errors during tokenization or parsing.

Finally, the main function takes the input string, applies the comment_parser function to it, then tokenizes and parses the resulting string to generate an AST, and finally evaluates the AST using the evaluate function. The function handles any exceptions or errors that occur during execution, such as parse errors or division by zero errors, and prints an appropriate error message to the console.

##  Any bugs or issues you could not resolve

As far as I remember I have resolved all the bugs which cropped up during testing, and I think there are no bugs which are yet to be resolved 

## An example of a difficult issue or bug

The process of implementing this program came with some difficulties that I had to overcome. 

Initially, I wrote the basic code and tested it locally with multiple test cases, which all worked fine. However, after submitting the code, I only got a few correct answers. I tried to correct the code as many times as possible, but it still didn't work. Finally, after carefully examining the output, I realized that I was printing an extra space character at the end of each answer. Once I removed the extra space character, many cases passed in Gradescope.

Another difficulty I faced was with the test cases in Gradescope. As mentioned earlier, my code was working for many inputs, but Gradescope was showing fewer test case passes. After receiving your message that the test case output was wrong (0 instead of 0.0) and correcting it, I finally saw that most of the cases passed.

For few submission I have encountered infinite loop problem as the gradescope showed runtime errror, later the issue was identified and corrected

## A list of the four extensions I've chosen to implement
1. Op-equals
2. Relational operations
3. Boolean operations
4. Comments
